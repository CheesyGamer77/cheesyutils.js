import ExpiryMap from 'expiry-map';

type KeygenFunc<Value, Key> = (v: Value) => Key

/**
 * Represents a write-front cache with an expiry eviction policy, supported by a "backend" (typically a database).
 *
 * Keys for added values are generated by a keygen function defined in the constructor.
 */
// TODO: Implement Map interface
export abstract class ExpiryCache<Key, Value> {
    private readonly entries: ExpiryMap<Key, Value>;
    private readonly keygenFunc: KeygenFunc<Value, Key>;

    constructor(expiry_ms: number, keygen: KeygenFunc<Value, Key>) {
        this.entries = new ExpiryMap(expiry_ms);
        this.keygenFunc = keygen;
    }

    /**
     * Gets an item from the cache.
     *
     * If the item is not already cached, this will return undefined.
     * @param key The key of the item to get.
     * @returns The value if cached, undefined otherwise.
     */
    public get(key: Key) {
        return this.entries.get(key);
    }

    /**
     * Retrieves an item identified by a particular key from the cache first, and the backend if the item is not cached.
     *
     * If the item is already cached, this will return the cached item. Otherwise, this will fetch and cache the item.
     * @param key The key of the item to retrieve.
     * @returns The item.
     */
    // return type is funky if the type annotation isn't there :shrug:
    public async retrieve(key: Key): Promise<Value> {
        return this.get(key) ?? await this.fetchAndCache(key);
    }

    /**
     * Fetches the value identified by a given key, then caches it.
     * @param key The key of the value to fetch and cache.
     * @returns The fetched and newly-cached item.
     */
    protected async fetchAndCache(key: Key) {
        const value = await this.fetch(key);
        this.entries.set(key, value);
        return value;
    }

    /**
     * Adds a value to the cache, then upserts it to the backend.
     *
     * If the value already exists, this replaces said value.
     * @param value The item to cache.
     * @returns The newly-cached item.
     */
    public async add(value: Value) {
        this.entries.set(this.keygenFunc(value), value);
        await this.upsert(value);

        return value;
    }

    /**
     * Deletes a value from the cache, as well as the backend.
     * @param key The key of the value to delete.
     */
    public async delete(key: Key) {
        const cached = this.entries.delete(key);
        return cached ? true : await this.drop(key);
    }

    /**
     * Updates the given item in the backend, or inserts the item if it doesn't already exist into the backend.
     *
     * This does not modify the cache.
     * @param value The value to upsert.
     */
    protected abstract upsert(value: Value): Promise<Value>

    /**
     * Fetches an item identified by a given key from the backend.
     *
     * This does not modify the cache.
     * @param key The key of the item to fetch.
     */
    public abstract fetch(key: Key): Promise<Value>

    /**
     * Drops an item (typically from a database).
     *
     * This does not modify the cache.
     *
     * Implementations are not required to handle invalid keys.
     * @param key The key of the item to delete.
     * @returns true if an item with the given key was deleted, false otherwise.
     */
    protected abstract drop(key: Key): Promise<boolean>
}

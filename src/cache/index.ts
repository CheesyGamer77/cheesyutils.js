import ExpiryMap from 'expiry-map';

type KeygenFunc<Value, Key> = (v: Value) => Key

/**
 * Represents a write-front cache with an expiry eviction policy.
 *
 * Keys for added values are generated by a keygen function defined in the constructor.
 */
// TODO: Implement Map interface
export abstract class ExpiryCache<Key, Value> {
    private readonly entries: ExpiryMap<Key, Value>;
    private readonly keygenFunc: KeygenFunc<Value, Key>;

    constructor(expiry_ms: number, keygen: KeygenFunc<Value, Key>) {
        this.entries = new ExpiryMap(expiry_ms);
        this.keygenFunc = keygen;
    }

    /**
     * Gets an item from the cache.
     *
     * If the item is not already cached, this will return undefined
     * @param key The key of the item to get.
     * @returns The value if cached, undefined otherwise.
     */
    public get(key: Key) {
        return this.entries.get(key);
    }

    /**
     * Retrieves an item from the cache identified by a particular key.
     *
     * If the item is already cached, this will return the cached item. Otherwise, this will fetch and cache the item.
     * @param key The key of the item to retrieve.
     * @returns The item.
     */
    // return type is funky if the type annotation isn't there :shrug:
    public async retrieve(key: Key): Promise<Value> {
        return this.get(key) ?? await this.fetchAndCache(key);
    }

    /**
     * Fetches the value identified by a given key, then caches it.
     * @param key The key of the value to fetch and cache.
     */
    protected async fetchAndCache(key: Key) {
        const value = await this.fetch(key);
        this.entries.set(key, value);
        return value;
    }

    /**
     * Adds a value to the cache. If the value already exists, this replaces said value.
     *
     * This also upserts the item via a write-front operation.
     * @param value The item to cache.
     */
    public async add(value: Value) {
        this.entries.set(this.keygenFunc(value), value);
        await this.upsert(value);

        return value;
    }

    /**
     * Deletes a value from the cache,
     * @param key The key of the value to delete.
     */
    public async delete(key: Key) {
        const cached = this.entries.delete(key);
        return cached ? true : await this.drop(key);
    }

    /**
     * Updates the given item, or inserts the item if it doesn't already exist.
     *
     * This does not modify the cache.
     * @param value The value to upsert.
     */
    protected abstract upsert(value: Value): Promise<Value>

    /**
     * Fetches an item identified by a given key.
     *
     * This does not modify the cache.
     * @param key The key of the item to fetch.
     */
    public abstract fetch(key: Key): Promise<Value>

    /**
     * Drops an item (typically a database).
     *
     * This does not modify the cache.
     *
     * Implementations may not assume that the given key is associated with an item in the cache.
     * @param key The key of the item to delete.
     * @returns true if an item with the given key was deleted, false otherwise.
     */
    public abstract drop(key: Key): Promise<boolean>
}
